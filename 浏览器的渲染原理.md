# 进程 Process
    进程是系统正在运行的一个程序，程序一旦运行就是一个进程

#   线程 Thread 
    有些进程还不止同时做一件事，要同时做多件事，就同时需要运行多个子任务，我们把进程里的这些子任务称为线程。

#   栈内存  Stack
    提供一个环境，供我们来执行代码。

` 浏览器是多线程,js 是单线程`
#   
    
    客户端(浏览器) ------------------------------------------------------------------------------------->服务器
        1，Request请求阶段(浏览器帮我们发的请求) ： DNS解析， TCP协议的三次握手和四次挥手  
    客户端(浏览器) <-------------------------------------------------------------------------------------服务器      
        2,Response响应阶段(服务器返回我们需要的页面代码)：HTTP状态码，304缓存,HTTP报文
    客户端(浏览器)
        3，浏览器拿到代码以后，就会在内存中开启一块栈内存(Stack),用来给执行代码提供环境，同时分配一个主线程去一行一行的解析和执行代码
    栈内存(Stack)
        4,因为是单线程的原因，所以浏览器会将代码一行一行的放进Stack里面执行(进栈)，执行完成后会将代码移出栈内存，或者是清空栈内存(出栈)
            当浏览器遇到link,img,script 等标签的时候，都会开辟新的线程去加载资源文件——————————————浏览器是多线程，但只分配了一个线程执行js。
            浏览器会将Link,img,script等异步任务放到Task queue中去请求资源，然后自己接着执行下面的代码
        
        5，浏览器自上而下第一次执行完所有代码的这个过程叫  生成叫dom树
        6，event loop 启动，查看消息队列里是否有代码需要执行，如果有就将他按顺序移动到Stack 中执行。消息队列分为两种：macroTask 和 microTask，microTask会比macroTask先执行
        7，css处理完成，然后生成CSSOM树
        8,浏览器会将dom树和 CSSOM树结合到一起生成Render tree(渲染树)
        9，Layout(回流) ： 根据生成的渲染树，计算他们在设置视口内的确切位置和大小，这个计算机的阶段叫回流(计算所有元素在设备视口的位置 )
        10，Painting(重绘) ： 根据渲染树以及回流得到的几何信息，得到节点的绝对像素，这个计算机的阶段叫重绘 (计算所有元素在设备视口的具体样式)
        11，通知GPU渲染页面 



#   重绘：
        元素的样式改变(单高宽大小，位置等不便)
#   回流
        元素的位置和大小发生了变化，触发了重新布局，导致渲染树重新计算布局和渲染
` 回流一定会触发重绘，单重绘不定发生回流`

# DNS解析
    域名转换成ip地址的过程就是DNS解析过程

    DNS解析过程
        1，查看浏览器自身缓冲有没有对应的ip记录 ，同时查询主机本地文件里有没有对应记录
        2，如果没有记录，浏览器就会向dns解析器(dns客户端)发起解析请求，然后dns解析器又会向本地dns服务器发起请求
` 建立TCP连接就是建立通道，用于传输数据`
#   TCP 三次握手和四次挥手(连接)
*       1，客户端发起报文SYN请求与服务器连接
        2，服务器响应请求返回报文SYN ACK 同意连接
        3,客户端发起确认请求报文SYN表示成功连接
       >  然后就建立客户端和端午段的传输通道
#   TCP 四次挥手(断开连接)
        1，客户端或服务端发起请求报文FIN  表示请求断开连接
        2，服务端响应报文ACK 表示自己进入关闭等待状态，这是还可以传输为传输完成的数据
        3，服务端再次发起一个报文FIN ACK表示数据传输完成，确认断开连接
        4，客户端放发起报文ACK确定成功断开连接，然后等待一段时间后断开连接，因为有可能网络原因造成 报文丢失，服务端如果长时间未收到确认断开的报文，就会重新发起FIN ACK  报文确定断开连接
        优点：传输数据稳定
        确定：性能损耗大，资源占用多

#   UDP协议
    UDP协议是基于非连接的，就是将数据包简单的封装一下，然后发出去。数据包并没有状态上的联系，所以容易产生丢包
    优点：性能损耗少，资源占用少,传输快
    缺点：传输不问题，因为网络传输中造成的丢包，UDP协议并不能保证，所以UDP在传输稳定性上要弱于TCP协议

#   为什么是三次握手而不是两次
    防止报文丢失
    有时候因为会因为网络原因造成报文a丢失，客户端会重新发起请求与服务器建立传输通道，然后可能某一刻之前报文a又发送到服务端了，这时候服务端就会认为建立了两个通道，而客户端认为只建立的一个通道，从而造成状态不一致。
    三次握手的目的是为了解决网络通信不可靠的问题

输入url到页面渲染
Request (dns解析  > 创建TCP通道(三次握手 > 发情http请求)) > 服务器响应并返回结果 > 浏览器开辟一个栈内存执行代码 > 生成dom树 > 生成cssom树 > 合并生成渲染树 > 回流确定元素的位置和大小 > 重绘确定元素的具体样式 > 通知GPU渲染页面 